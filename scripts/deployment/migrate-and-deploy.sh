#!/bin/bash
set -e

# ================================================
# Skepsis Backend - Complete Migration & Deployment
# ================================================
# This script handles:
# 1. Database backup
# 2. Schema migrations (indexes, new fields)
# 3. Code deployment
# 4. Service restart
# 5. Verification
# ================================================

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
APP_NAME="skepsis-backend"
BACKUP_DIR="/home/ubuntu/backups"
LOG_FILE="/tmp/deployment-$(date +%Y%m%d-%H%M%S).log"

# Functions
log() {
    echo -e "${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')]${NC} $1" | tee -a $LOG_FILE
}

error() {
    echo -e "${RED}[ERROR]${NC} $1" | tee -a $LOG_FILE
}

warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1" | tee -a $LOG_FILE
}

info() {
    echo -e "${BLUE}[INFO]${NC} $1" | tee -a $LOG_FILE
}

# Banner
echo ""
echo "================================================"
echo "  Skepsis Backend - Migration & Deployment"
echo "================================================"
echo ""

# ================================================
# PHASE 0: Pre-flight Checks
# ================================================
log "Phase 0: Pre-flight checks..."

# Check if running as root (not recommended but works)
if [ "$EUID" -eq 0 ]; then 
    warning "Running as root. Consider using a dedicated user."
fi

# Auto-detect app directory
if [ -f "package.json" ]; then
    APP_DIR=$(pwd)
elif [ -d "/home/ubuntu/skepsis-backend" ]; then
    APP_DIR="/home/ubuntu/skepsis-backend"
elif [ -d "/home/ubuntu/backend-api" ]; then
    APP_DIR="/home/ubuntu/backend-api"
else
    error "Application directory not found!"
    exit 1
fi

log "App directory: $APP_DIR"
cd $APP_DIR

# Check for .env file
if [ ! -f ".env" ]; then
    error ".env file not found! Please create it first."
    exit 1
fi

# Load environment variables
source .env

# Validate critical env vars
if [ -z "$MONGODB_URI" ]; then
    error "MONGODB_URI not set in .env"
    exit 1
fi

log "âœ… Pre-flight checks passed"
echo ""

# ================================================
# PHASE 1: Backup
# ================================================
log "Phase 1: Backing up database..."

# Create backup directory if it doesn't exist
mkdir -p $BACKUP_DIR

# Generate backup name
BACKUP_NAME="pre-migration-$(date +%Y%m%d-%H%M%S)"
BACKUP_PATH="$BACKUP_DIR/$BACKUP_NAME"

# Backup database
if command -v mongodump &> /dev/null; then
    log "Running mongodump..."
    mongodump --uri="$MONGODB_URI" --out="$BACKUP_PATH" >> $LOG_FILE 2>&1
    log "âœ… Backup created: $BACKUP_PATH"
else
    warning "mongodump not found. Skipping backup..."
    warning "Install mongodb-database-tools for backup support"
fi

# Save current git commit for rollback
CURRENT_COMMIT=$(git rev-parse HEAD)
echo $CURRENT_COMMIT > /tmp/pre-deploy-commit.txt
log "Current commit saved: $CURRENT_COMMIT"
echo ""

# ================================================
# PHASE 2: Database Migrations
# ================================================
log "Phase 2: Running database migrations..."

# Create migration script
MIGRATION_SCRIPT="/tmp/migration-script-$(date +%Y%m%d-%H%M%S).js"

cat > $MIGRATION_SCRIPT << 'MIGRATION_EOF'
// MongoDB Migration Script
// Generated by migrate-and-deploy.sh

const { MongoClient } = require('mongodb');

async function migrate() {
    const uri = process.env.MONGODB_URI;
    
    if (!uri) {
        console.error('âŒ MONGODB_URI not set');
        process.exit(1);
    }
    
    console.log('ğŸ”Œ Connecting to MongoDB...');
    const client = await MongoClient.connect(uri);
    const db = client.db();
    
    console.log('âœ… Connected to database:', db.databaseName);
    console.log('');
    
    // ================================================
    // Migration 1: Waitlist - Email System
    // ================================================
    console.log('ğŸ“‹ Migration 1: Waitlist email system...');
    
    try {
        // Check current state
        const waitlistCount = await db.collection('waitlist').countDocuments();
        console.log(`   Total waitlist entries: ${waitlistCount}`);
        
        // Drop old contact unique index
        console.log('   ğŸ”„ Dropping old contact unique index...');
        try {
            await db.collection('waitlist').dropIndex('contact_1');
            console.log('   âœ… Dropped contact_1 index');
        } catch (e) {
            console.log('   â„¹ï¸  Index already dropped or does not exist');
        }
        
        // Create new email index (sparse to allow old entries)
        console.log('   ğŸ“ Creating new email index...');
        await db.collection('waitlist').createIndex(
            { email: 1 }, 
            { unique: true, sparse: true }
        );
        console.log('   âœ… Created email_1 index (unique, sparse)');
        
        // Add newsletter_consent to existing entries
        console.log('   ğŸ”„ Adding newsletter_consent to existing entries...');
        const result1 = await db.collection('waitlist').updateMany(
            { newsletter_consent: { $exists: false } },
            { $set: { newsletter_consent: false } }
        );
        console.log(`   âœ… Updated ${result1.modifiedCount} documents`);
        
    } catch (error) {
        console.error('   âŒ Error in waitlist migration:', error.message);
        throw error;
    }
    
    console.log('');
    
    // ================================================
    // Migration 2: User Positions - PnL Fields
    // ================================================
    console.log('ğŸ“‹ Migration 2: User positions PnL fields...');
    
    try {
        const positionsCount = await db.collection('user_positions').countDocuments();
        console.log(`   Total user positions: ${positionsCount}`);
        
        // Add unrealized_pnl field to existing positions
        console.log('   ğŸ”„ Adding unrealized_pnl field...');
        const result2 = await db.collection('user_positions').updateMany(
            { unrealized_pnl: { $exists: false } },
            { $set: { unrealized_pnl: '0' } }
        );
        console.log(`   âœ… Updated ${result2.modifiedCount} documents`);
        
        // close_reason is optional, no migration needed
        console.log('   â„¹ï¸  close_reason field is optional, no action needed');
        
    } catch (error) {
        console.error('   âŒ Error in user_positions migration:', error.message);
        throw error;
    }
    
    console.log('');
    
    // ================================================
    // Migration 3: Position Events - Realized PnL
    // ================================================
    console.log('ğŸ“‹ Migration 3: Position events realized PnL...');
    
    try {
        const eventsCount = await db.collection('position_events').countDocuments();
        console.log(`   Total position events: ${eventsCount}`);
        
        // realized_pnl_delta is optional, no migration needed
        console.log('   â„¹ï¸  realized_pnl_delta field is optional, no action needed');
        console.log('   â„¹ï¸  New events from indexer will include this field');
        
    } catch (error) {
        console.error('   âŒ Error in position_events migration:', error.message);
        throw error;
    }
    
    console.log('');
    
    // ================================================
    // Verification
    // ================================================
    console.log('ğŸ” Verifying migrations...');
    
    // Check indexes
    const waitlistIndexes = await db.collection('waitlist').indexes();
    const hasEmailIndex = waitlistIndexes.some(idx => idx.key.email === 1);
    const hasContactIndex = waitlistIndexes.some(idx => idx.key.contact === 1 && idx.unique === true);
    
    console.log('   Email index exists:', hasEmailIndex ? 'âœ…' : 'âŒ');
    console.log('   Old contact index removed:', !hasContactIndex ? 'âœ…' : 'âš ï¸  Still exists');
    
    // Check field presence
    const withUnrealizedPnl = await db.collection('user_positions').countDocuments({
        unrealized_pnl: { $exists: true }
    });
    const withNewsletter = await db.collection('waitlist').countDocuments({
        newsletter_consent: { $exists: true }
    });
    
    console.log(`   Positions with unrealized_pnl: ${withUnrealizedPnl}/${positionsCount}`);
    console.log(`   Waitlist with newsletter_consent: ${withNewsletter}/${waitlistCount}`);
    
    console.log('');
    console.log('âœ… All migrations completed successfully!');
    
    await client.close();
}

// Run migration
migrate()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error('ğŸ’¥ Migration failed:', error);
        process.exit(1);
    });
MIGRATION_EOF

# Run migration
log "Executing migration script..."
MONGODB_URI="$MONGODB_URI" node $MIGRATION_SCRIPT

if [ $? -eq 0 ]; then
    log "âœ… Database migrations completed successfully"
else
    error "Database migration failed! Check $LOG_FILE for details"
    error "Rollback may be required"
    exit 1
fi

# Cleanup migration script
rm $MIGRATION_SCRIPT
echo ""

# ================================================
# PHASE 3: Code Deployment
# ================================================
log "Phase 3: Deploying code..."

# Stash any local changes
if ! git diff-index --quiet HEAD --; then
    warning "Local changes detected, stashing..."
    git stash >> $LOG_FILE 2>&1
fi

# Pull latest code
log "Pulling latest code from origin/main..."
git fetch origin >> $LOG_FILE 2>&1
git checkout main >> $LOG_FILE 2>&1
git pull origin main >> $LOG_FILE 2>&1

# Save new commit
NEW_COMMIT=$(git rev-parse HEAD)
log "New commit: $NEW_COMMIT"

# Install dependencies
log "Installing dependencies..."
npm ci >> $LOG_FILE 2>&1

# Build TypeScript
log "Building TypeScript..."
npm run build >> $LOG_FILE 2>&1

log "âœ… Code deployment completed"
echo ""

# ================================================
# PHASE 4: Service Restart
# ================================================
log "Phase 4: Restarting service..."

# Detect process manager
if command -v pm2 &> /dev/null; then
    log "Using PM2..."
    
    # Check if app is running
    if pm2 list | grep -q $APP_NAME; then
        log "Restarting $APP_NAME..."
        pm2 restart $APP_NAME >> $LOG_FILE 2>&1
    else
        log "Starting $APP_NAME for the first time..."
        pm2 start npm --name $APP_NAME -- start >> $LOG_FILE 2>&1
        pm2 save >> $LOG_FILE 2>&1
    fi
    
    # Show status
    pm2 status $APP_NAME
    
elif command -v systemctl &> /dev/null && systemctl is-active --quiet $APP_NAME; then
    log "Using systemd..."
    sudo systemctl restart $APP_NAME
    sudo systemctl status $APP_NAME --no-pager
    
else
    warning "No process manager detected"
    warning "Please restart your application manually"
fi

log "âœ… Service restart completed"
echo ""

# ================================================
# PHASE 5: Verification
# ================================================
log "Phase 5: Verifying deployment..."

# Wait for app to start
sleep 3

# Extract port from .env
PORT=${PORT:-3000}

# Test endpoints
log "Testing API endpoints..."

# Test 1: Health check (if available)
if curl -f -s "http://localhost:$PORT/api/markets" > /dev/null 2>&1; then
    log "âœ… API is responding"
else
    warning "âš ï¸  API may not be responding yet, check logs"
fi

# Test 2: Check logs for errors
if command -v pm2 &> /dev/null; then
    log "Recent logs:"
    pm2 logs $APP_NAME --lines 20 --nostream
fi

echo ""

# ================================================
# Summary
# ================================================
echo "================================================"
log "ğŸ‰ Deployment completed successfully!"
echo "================================================"
echo ""
info "Summary:"
info "  Backup: $BACKUP_PATH"
info "  Previous commit: $CURRENT_COMMIT"
info "  New commit: $NEW_COMMIT"
info "  Log file: $LOG_FILE"
echo ""
info "Rollback instructions (if needed):"
echo "  cd $APP_DIR"
echo "  git checkout $CURRENT_COMMIT"
echo "  npm ci && npm run build"
echo "  pm2 restart $APP_NAME"
echo "  mongorestore --uri=\"\$MONGODB_URI\" $BACKUP_PATH"
echo ""
info "Next steps:"
info "  1. Monitor logs: pm2 logs $APP_NAME"
info "  2. Test critical features"
info "  3. Check MongoDB for data integrity"
echo ""

# ================================================
# Post-deployment tests
# ================================================
echo "Would you like to run post-deployment tests? (y/n)"
read -t 10 -r REPLY || REPLY="n"
echo ""

if [[ $REPLY =~ ^[Yy]$ ]]; then
    log "Running post-deployment tests..."
    
    # Test 1: Waitlist email signup
    log "Test 1: Email waitlist signup"
    TEST_EMAIL="test-$(date +%s)@example.com"
    RESPONSE=$(curl -s -X POST "http://localhost:$PORT/api/waitlist/join" \
        -H "Content-Type: application/json" \
        -d "{\"email\":\"$TEST_EMAIL\",\"newsletter_consent\":true}")
    
    if echo "$RESPONSE" | grep -q "access_code\|Already registered"; then
        log "âœ… Waitlist endpoint working"
    else
        warning "âš ï¸  Waitlist endpoint may have issues"
        echo "Response: $RESPONSE"
    fi
    
    # Test 2: Markets endpoint
    log "Test 2: Markets endpoint"
    MARKETS=$(curl -s "http://localhost:$PORT/api/markets")
    if [ -n "$MARKETS" ] && [ "$MARKETS" != "null" ]; then
        log "âœ… Markets endpoint working"
    else
        warning "âš ï¸  Markets endpoint may have issues"
    fi
    
    # Test 3: Database connection
    log "Test 3: Database connectivity"
    MONGO_TEST=$(mongo "$MONGODB_URI" --quiet --eval "db.adminCommand('ping').ok" 2>/dev/null || echo "0")
    if [ "$MONGO_TEST" = "1" ]; then
        log "âœ… Database connection working"
    else
        warning "âš ï¸  Database connection may have issues"
    fi
    
    echo ""
    log "âœ… Post-deployment tests completed"
fi

echo ""
log "ğŸš€ All done! Your backend is live."
echo ""
